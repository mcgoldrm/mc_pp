<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>College Policy Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .chat-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 800px;
            height: 600px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .chat-header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }
        
        .chat-header h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }
        
        .chat-header p {
            opacity: 0.9;
            font-size: 0.9rem;
        }
        
        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #e74c3c;
            animation: pulse 2s infinite;
        }
        
        .status-dot.ready {
            background: #2ecc71;
            animation: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .message {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 18px;
            line-height: 1.4;
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-message {
            background: #007bff;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }
        
        .bot-message {
            background: #f8f9fa;
            color: #333;
            border: 1px solid #e9ecef;
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }
        
        .bot-message .source-info {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #dee2e6;
            font-size: 0.8rem;
            color: #6c757d;
        }
        
        .source-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .relevance-score {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            color: #495057;
        }
        
        .loading-bar {
            width: 100%;
            height: 4px;
            background: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #0056b3);
            border-radius: 2px;
            transition: width 0.3s ease;
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { background-position: -200px 0; }
            100% { background-position: 200px 0; }
        }
        
        .typing-indicator {
            display: none;
            align-self: flex-start;
            background: #f8f9fa;
            padding: 12px 16px;
            border-radius: 18px;
            border-bottom-left-radius: 4px;
        }
        
        .typing-dots {
            display: flex;
            gap: 4px;
        }
        
        .typing-dots span {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #007bff;
            animation: typing 1.4s infinite;
        }
        
        .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }
        
        .chat-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
        }
        
        .input-container {
            flex: 1;
            position: relative;
        }
        
        #messageInput {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e9ecef;
            border-radius: 25px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s ease;
        }
        
        #messageInput:focus {
            border-color: #007bff;
        }
        
        #sendButton {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        #sendButton:hover:not(:disabled) {
            background: #0056b3;
            transform: scale(1.05);
        }
        
        #sendButton:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        
        .config-panel {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .config-row {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .config-row label {
            font-weight: 600;
            min-width: 100px;
        }
        
        .config-row input, .config-row select {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
        }
        
        .welcome-message {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            margin: 40px 0;
        }
        
        @media (max-width: 600px) {
            .chat-container {
                height: 100vh;
                border-radius: 0;
            }
            
            .message {
                max-width: 90%;
            }
            
            .config-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .config-row label {
                min-width: auto;
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <h1>🎓 College Policy Assistant</h1>
            <p>Ask questions about our policies and procedures</p>
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Setup Required</span>
            </div>
        </div>
        
        <div class="chat-messages" id="chatMessages">
            <div class="config-panel" id="configPanel">
                <h3 style="margin-bottom: 15px; color: #333;">🔧 Configuration</h3>
                <div class="config-row">
                    <label for="apiKey">Groq API Key:</label>
                    <input type="password" id="apiKey" placeholder="Enter your Groq API key">
                    <small style="color: #6c757d; font-size: 0.8rem; margin-top: 4px; display: block;">
                        Get your free API key from <a href="https://console.groq.com/keys" target="_blank">console.groq.com</a>
                    </small>
                </div>
                <div class="config-row">
                    <label for="pdfFolder">PDF Folder URL:</label>
                    <input type="text" id="pdfFolder" placeholder="https://your-username.github.io/your-repo/pdf/">
                </div>
                <div class="config-row">
                    <label for="pdfFiles">PDF Files (optional):</label>
                    <input type="text" id="pdfFiles" placeholder="file1.pdf, file2.pdf, file3.pdf">
                    <small style="color: #6c757d; font-size: 0.8rem; margin-top: 4px; display: block;">
                        Leave blank to auto-discover, or list specific filenames separated by commas
                    </small>
                </div>
                <button onclick="initializeBot()" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 10px;">
                    Initialize Assistant
                </button>
            </div>
            
            <div class="welcome-message" id="welcomeMessage" style="display: none;">
                Welcome! I'm ready to help you find information about college policies and procedures. What would you like to know?
                <br><br>
                <small style="color: #6c757d;">
                    💡 <strong>Tips:</strong> Try asking about specific topics like "board responsibilities", "student conduct", or "meeting procedures"<br>
                    🔍 <strong>Debug:</strong> Press Ctrl+Enter to see document statistics
                </small>
            </div>
            
            <div class="typing-indicator" id="typingIndicator">
                <div class="typing-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        
        <div class="chat-input">
            <div class="input-container">
                <input type="text" id="messageInput" placeholder="Ask about policies, procedures, or guidelines..." disabled>
            </div>
            <button id="sendButton" disabled onclick="sendMessage()">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                </svg>
            </button>
        </div>
    </div>

    <!-- PDF.js for PDF processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <script>
        // Configuration
        let config = {
            apiKey: '',
            provider: 'openai',
            pdfFolderUrl: '',
            isInitialized: false
        };
        
        // Document storage
        let documentChunks = [];
        let embeddings = [];
        let loadingProgress = 0;
        
        // Common PDF files to look for in the folder
        const commonPolicyFiles = [
            // Standard patterns
            'student-handbook.pdf',
            'employee-handbook.pdf',
            'academic-policies.pdf',
            'campus-safety.pdf',
            'technology-policies.pdf',
            'facilities-policies.pdf',
            'hr-policies.pdf',
            'financial-policies.pdf',
            'student-code-of-conduct.pdf',
            'faculty-handbook.pdf',
            'emergency-procedures.pdf',
            'it-acceptable-use.pdf',
            // Alternative patterns
            'handbook.pdf',
            'policies.pdf',
            'student-policies.pdf',
            'employee-policies.pdf',
            'staff-policies.pdf',
            'manual.pdf',
            'guidelines.pdf',
            'procedures.pdf',
            'catalog.pdf',
            'code-of-conduct.pdf',
            // Chapter-based patterns (common in policy manuals)
            'Chapter I - Board of Trustees.pdf',
            'Chapter II - Administration.pdf',
            'Chapter III - Students.pdf',
            'Chapter IV - Academic Affairs.pdf',
            'Chapter V - Student Affairs.pdf',
            'Chapter VI - Business Affairs.pdf',
            'Chapter VII - Human Resources.pdf',
            'Chapter VIII - Facilities.pdf',
            'Chapter 1 - Board of Trustees.pdf',
            'Chapter 2 - Administration.pdf',
            'Chapter 3 - Students.pdf',
            'Chapter 4 - Academic Affairs.pdf',
            'Chapter 5 - Student Affairs.pdf',
            'Chapter 6 - Business Affairs.pdf',
            'Chapter 7 - Human Resources.pdf',
            'Chapter 8 - Facilities.pdf',
            // Board policies patterns
            'board-policies.pdf',
            'board-of-trustees.pdf',
            'governance.pdf',
            'administrative-policies.pdf',
            'student-policies.pdf',
            'academic-regulations.pdf',
            'personnel-policies.pdf'
        ];

        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        async function initializeBot() {
            const apiKey = document.getElementById('apiKey').value;
            let pdfFolder = document.getElementById('pdfFolder').value;
            const customFiles = document.getElementById('pdfFiles').value;

            // Validation
            if (!apiKey || !pdfFolder) {
                alert('Please fill in Groq API key and PDF folder URL');
                return;
            }

            // Normalize PDF folder URL
            if (!pdfFolder.endsWith('/')) {
                pdfFolder += '/';
            }
            if (!pdfFolder.startsWith('http')) {
                alert('PDF Folder URL must start with http:// or https://');
                return;
            }

            // Parse custom file list
            let customFileList = [];
            if (customFiles.trim()) {
                customFileList = customFiles.split(',')
                    .map(file => file.trim())
                    .filter(file => file.length > 0)
                    .filter(file => file.toLowerCase().endsWith('.pdf'));
                
                if (customFileList.length === 0) {
                    alert('Please enter valid PDF filenames (must end with .pdf)');
                    return;
                }
            }

            config = { 
                provider: 'groq', // Always use Groq
                apiKey, 
                pdfFolderUrl: pdfFolder, 
                customFiles: customFileList,
                isInitialized: false 
            };
            
            updateStatus('Initializing...', false);
            showLoadingProgress(0);
            
            try {
                // Test API key first
                updateStatus('Testing Groq API connection...', false);
                await testAPIConnection();
                showLoadingProgress(20);
                
                // Test PDF folder access
                updateStatus('Testing PDF folder access...', false);
                await testPDFFolder();
                showLoadingProgress(40);
                
                // Load documents
                updateStatus('Loading documents...', false);
                await loadDocuments();
                showLoadingProgress(100);
                
                // Success!
                config.isInitialized = true;
                
                // Hide config panel and show welcome
                document.getElementById('configPanel').style.display = 'none';
                document.getElementById('welcomeMessage').style.display = 'block';
                hideLoadingProgress();
                
                // Enable input
                document.getElementById('messageInput').disabled = false;
                document.getElementById('sendButton').disabled = false;
                
                updateStatus('Ready', true);
                
                // Show success message
                addMessage(`🎉 Successfully loaded ${documentChunks.length} document chunks from your policy files! I'm ready to answer questions using Groq's Llama models.`, 'bot');
                
                // Focus on input
                document.getElementById('messageInput').focus();
                
            } catch (error) {
                console.error('Initialization failed:', error);
                updateStatus('Setup Required', false);
                hideLoadingProgress();
                
                // Show detailed error message
                let errorMessage = 'Failed to initialize. ';
                
                if (error.message.includes('API')) {
                    errorMessage += 'Please check your Groq API key and try again.';
                } else if (error.message.includes('PDF folder')) {
                    errorMessage += 'Please check your PDF folder URL and ensure it\'s accessible.';
                } else if (error.message.includes('No PDF files')) {
                    errorMessage += 'No PDF files were found. Please check your configuration.';
                } else {
                    errorMessage += `Error: ${error.message}`;
                }
                
                alert(errorMessage);
                addMessage(`❌ Initialization failed: ${error.message}`, 'bot');
            }
        }

        async function testAPIConnection() {
            try {
                // Test Groq API
                const response = await fetch('https://api.groq.com/openai/v1/models', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${config.apiKey}`
                    }
                });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        throw new Error('Invalid Groq API key');
                    } else {
                        throw new Error(`Groq API error: ${response.status}`);
                    }
                }
            } catch (error) {
                if (error.message.includes('Failed to fetch')) {
                    throw new Error('API connection failed - please check your internet connection');
                }
                throw error;
            }
        }

        async function testPDFFolder() {
            try {
                // Test if we can access the PDF folder by trying to fetch a common file
                addMessage(`🔍 Testing PDF folder access: ${config.pdfFolderUrl}`, 'bot');
                
                const testResponse = await fetch(config.pdfFolderUrl, { method: 'HEAD' });
                
                // Show the exact URL being tested
                addMessage(`📍 Testing URL: ${config.pdfFolderUrl}`, 'bot');
                addMessage(`📊 Response status: ${testResponse.status} ${testResponse.statusText}`, 'bot');
                
                // Even if the folder returns 404, that's okay - we just need to know we can reach the domain
                // The real test is when we try to discover files
                
            } catch (error) {
                addMessage(`❌ Network error: ${error.message}`, 'bot');
                throw new Error('PDF folder URL is not accessible - please check the URL and ensure GitHub Pages is deployed');
            }
        }

        function showLoadingProgress(percentage) {
            let progressBar = document.getElementById('loadingProgress');
            if (!progressBar) {
                // Create progress bar
                const progressContainer = document.createElement('div');
                progressContainer.innerHTML = `
                    <div class="loading-bar">
                        <div class="loading-progress" id="loadingProgress" style="width: 0%"></div>
                    </div>
                `;
                document.getElementById('configPanel').appendChild(progressContainer);
                progressBar = document.getElementById('loadingProgress');
            }
            progressBar.style.width = percentage + '%';
        }

        function hideLoadingProgress() {
            const progressBar = document.querySelector('.loading-bar');
            if (progressBar) {
                progressBar.remove();
            }
        }

        async function loadDocuments() {
            updateStatus('Discovering PDF files...', false);
            
            try {
                // Discover available PDF files
                const availableFiles = await discoverPDFFiles();
                console.log(`Found ${availableFiles.length} PDF files to process`);
                
                if (availableFiles.length === 0) {
                    throw new Error('No PDF files found in the specified folder. Please check that your PDF folder URL is correct and contains PDF files.');
                }
                
                // Show what we found
                addMessage(`📁 Found ${availableFiles.length} PDF file(s): ${availableFiles.join(', ')}`, 'bot');
                
                // Process each PDF
                documentChunks = [];
                embeddings = [];
                loadingProgress = 0;
                
                for (let i = 0; i < availableFiles.length; i++) {
                    const fileName = availableFiles[i];
                    const progress = Math.round(((i + 1) / availableFiles.length) * 80); // Reserve 20% for embeddings
                    
                    updateStatus(`Processing ${fileName}... (${i + 1}/${availableFiles.length})`, false);
                    showLoadingProgress(20 + progress);
                    
                    try {
                        const chunks = await processPDF(fileName);
                        documentChunks.push(...chunks);
                        console.log(`Processed ${fileName}: ${chunks.length} chunks`);
                        addMessage(`✅ Processed ${fileName}: ${chunks.length} text segments`, 'bot');
                    } catch (error) {
                        console.error(`Failed to process ${fileName}:`, error);
                        addMessage(`⚠️ Could not process ${fileName}: ${error.message}`, 'bot');
                        // Continue with other files
                    }
                }
                
                if (documentChunks.length === 0) {
                    throw new Error('No content could be extracted from PDF files. Please check that the PDF files are not password-protected or corrupted.');
                }
                
                // Generate embeddings for all chunks
                updateStatus('Generating embeddings...', false);
                showLoadingProgress(85);
                
                try {
                    await generateAllEmbeddings();
                    console.log(`Successfully generated embeddings for ${documentChunks.length} document chunks`);
                } catch (error) {
                    console.error('Embedding generation failed:', error);
                    // For now, continue without embeddings - we'll fall back to keyword search
                    addMessage(`⚠️ Embedding generation failed, using keyword search fallback`, 'bot');
                }
                
                console.log(`Successfully loaded ${documentChunks.length} document chunks`);
                
            } catch (error) {
                console.error('Document loading failed:', error);
                throw error;
            }
        }

        async function discoverPDFFiles() {
            // If custom files are specified, use those
            if (config.customFiles && config.customFiles.length > 0) {
                console.log(`Using custom file list: ${config.customFiles.join(', ')}`);
                
                const availableFiles = [];
                
                for (const fileName of config.customFiles) {
                    try {
                        const fileUrl = `${config.pdfFolderUrl}${fileName}`;
                        console.log(`Testing custom file: ${fileUrl}`);
                        
                        const response = await fetch(fileUrl, { 
                            method: 'HEAD',
                            mode: 'cors'
                        });
                        
                        if (response.ok) {
                            availableFiles.push(fileName);
                            console.log(`✓ Found: ${fileName}`);
                        } else {
                            console.log(`✗ Not found: ${fileName} (${response.status})`);
                            throw new Error(`File not found: ${fileName}`);
                        }
                    } catch (error) {
                        console.error(`Error checking ${fileName}:`, error);
                        throw new Error(`Cannot access file: ${fileName}. Please check the filename and ensure it exists in your PDF folder.`);
                    }
                }
                
                return availableFiles;
            }
            
            // Auto-discovery mode
            console.log(`Auto-discovering files in: ${config.pdfFolderUrl}`);
            const availableFiles = [];
            
            // Try common policy file names
            const testFiles = [...commonPolicyFiles];
            
            for (const fileName of testFiles) {
                try {
                    const fileUrl = `${config.pdfFolderUrl}${fileName}`;
                    console.log(`Testing: ${fileUrl}`);
                    
                    const response = await fetch(fileUrl, { 
                        method: 'HEAD',
                        mode: 'cors'
                    });
                    
                    if (response.ok) {
                        availableFiles.push(fileName);
                        console.log(`✓ Found: ${fileName}`);
                    }
                } catch (error) {
                    // Continue silently for auto-discovery
                }
                
                // Add small delay to avoid overwhelming the server
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            
            // If no common files found, try alternative patterns
            if (availableFiles.length === 0) {
                console.log('No common policy files found. Trying alternative patterns...');
                
                const alternativePatterns = [
                    'handbook.pdf',
                    'policies.pdf',
                    'student-policies.pdf',
                    'employee-policies.pdf',
                    'staff-policies.pdf',
                    'manual.pdf',
                    'guidelines.pdf',
                    'procedures.pdf',
                    'catalog.pdf',
                    'code-of-conduct.pdf'
                ];
                
                for (const fileName of alternativePatterns) {
                    try {
                        const fileUrl = `${config.pdfFolderUrl}${fileName}`;
                        const response = await fetch(fileUrl, { 
                            method: 'HEAD', 
                            mode: 'cors' 
                        });
                        
                        if (response.ok) {
                            availableFiles.push(fileName);
                            console.log(`✓ Found alternative file: ${fileName}`);
                        }
                    } catch (error) {
                        // Continue silently
                    }
                }
            }
            
            console.log(`Discovery complete. Found ${availableFiles.length} files:`, availableFiles);
            return availableFiles;
        }

        async function processPDF(fileName) {
            const pdfUrl = `${config.pdfFolderUrl}${fileName}`;
            
            try {
                // Load PDF
                const loadingTask = pdfjsLib.getDocument(pdfUrl);
                const pdf = await loadingTask.promise;
                
                const chunks = [];
                const chunkSize = 1000; // Characters per chunk
                const overlapSize = 200; // Overlap between chunks
                
                // Process each page
                for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                    const page = await pdf.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    
                    // Extract text from page
                    const pageText = textContent.items
                        .map(item => item.str)
                        .join(' ')
                        .replace(/\s+/g, ' ')
                        .trim();
                    
                    if (pageText.length > 50) { // Only process pages with substantial content
                        // Split page into chunks
                        const pageChunks = createTextChunks(pageText, chunkSize, overlapSize);
                        
                        pageChunks.forEach((chunkText, chunkIndex) => {
                            chunks.push({
                                text: chunkText,
                                source: fileName,
                                page: pageNum,
                                chunkId: `${fileName}_p${pageNum}_c${chunkIndex}`,
                                wordCount: chunkText.split(' ').length
                            });
                        });
                    }
                }
                
                return chunks;
                
            } catch (error) {
                console.error(`Error processing PDF ${fileName}:`, error);
                throw new Error(`Failed to process ${fileName}: ${error.message}`);
            }
        }

        function createTextChunks(text, chunkSize, overlapSize) {
            const chunks = [];
            let startIndex = 0;
            
            while (startIndex < text.length) {
                let endIndex = startIndex + chunkSize;
                
                // If we're not at the end, try to break at a sentence or word boundary
                if (endIndex < text.length) {
                    // Look for sentence boundary
                    const sentenceEnd = text.lastIndexOf('.', endIndex);
                    const questionEnd = text.lastIndexOf('?', endIndex);
                    const exclamationEnd = text.lastIndexOf('!', endIndex);
                    
                    const bestSentenceEnd = Math.max(sentenceEnd, questionEnd, exclamationEnd);
                    
                    if (bestSentenceEnd > startIndex + chunkSize * 0.7) {
                        endIndex = bestSentenceEnd + 1;
                    } else {
                        // Fallback to word boundary
                        const wordEnd = text.lastIndexOf(' ', endIndex);
                        if (wordEnd > startIndex + chunkSize * 0.7) {
                            endIndex = wordEnd;
                        }
                    }
                }
                
                const chunk = text.slice(startIndex, endIndex).trim();
                if (chunk.length > 100) { // Only add substantial chunks
                    chunks.push(chunk);
                }
                
                // Move start index, accounting for overlap
                startIndex = endIndex - overlapSize;
                if (startIndex >= text.length) break;
            }
            
            return chunks;
        }

        async function generateAllEmbeddings() {
            embeddings = [];
            
            // Since we're only using Groq, use TF-IDF embeddings
            // (Groq doesn't have embedding endpoints like OpenAI)
            console.log('Generating TF-IDF embeddings for semantic search...');
            embeddings = generateTFIDFEmbeddings(documentChunks);
            
            console.log(`Generated embeddings for ${embeddings.length} chunks`);
        }

        async function generateEmbeddingBatch(chunks) {
            if (config.provider === 'openai') {
                return await generateOpenAIEmbeddings(chunks);
            } else {
                // For Llama, we'll use a simple TF-IDF approach as embeddings
                return generateTFIDFEmbeddings(chunks);
            }
        }

        async function generateOpenAIEmbeddings(chunks) {
            try {
                const response = await fetch('https://api.openai.com/v1/embeddings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'text-embedding-3-small',
                        input: chunks.map(chunk => chunk.text)
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                return data.data.map(item => item.embedding);
                
            } catch (error) {
                console.error('Error generating OpenAI embeddings:', error);
                // Fallback to TF-IDF
                return generateTFIDFEmbeddings(chunks);
            }
        }

        function generateTFIDFEmbeddings(chunks) {
            // Simple TF-IDF implementation for embeddings
            const vocabulary = new Set();
            const documents = chunks.map(chunk => {
                const words = chunk.text.toLowerCase()
                    .replace(/[^\w\s]/g, ' ')
                    .split(/\s+/)
                    .filter(word => word.length > 2);
                
                words.forEach(word => vocabulary.add(word));
                return words;
            });

            const vocabArray = Array.from(vocabulary);
            const embeddings = [];

            documents.forEach(doc => {
                const embedding = new Array(Math.min(vocabArray.length, 384)).fill(0);
                const docLength = doc.length;

                doc.forEach(word => {
                    const index = vocabArray.indexOf(word);
                    if (index !== -1 && index < embedding.length) {
                        embedding[index] += 1 / docLength; // Simple TF
                    }
                });

                // Normalize
                const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
                if (magnitude > 0) {
                    for (let i = 0; i < embedding.length; i++) {
                        embedding[i] /= magnitude;
                    }
                }

                embeddings.push(embedding);
            });

            return embeddings;
        }

        function updateStatus(text, ready) {
            document.getElementById('statusText').textContent = text;
            document.getElementById('statusDot').className = ready ? 'status-dot ready' : 'status-dot';
        }

        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message || !config.isInitialized) return;
            
            // Add user message
            addMessage(message, 'user');
            input.value = '';
            
            // Show typing indicator
            showTyping(true);
            
            try {
                const response = await generateResponse(message);
                addMessage(response.text, 'bot', response.sources);
            } catch (error) {
                console.error('Error generating response:', error);
                addMessage('I apologize, but I encountered an error processing your question. Please try again.', 'bot');
            } finally {
                showTyping(false);
            }
        }

        // Add debug command
        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && e.ctrlKey) {
                // Debug command - show document stats
                e.preventDefault();
                addMessage('📊 Document Statistics:', 'bot');
                addMessage(`Total chunks: ${documentChunks.length}`, 'bot');
                
                if (documentChunks.length > 0) {
                    const avgLength = Math.round(documentChunks.reduce((sum, chunk) => sum + chunk.text.length, 0) / documentChunks.length);
                    addMessage(`Average chunk length: ${avgLength} characters`, 'bot');
                    addMessage(`Sample text: "${documentChunks[0].text.substring(0, 200)}..."`, 'bot');
                }
            }
        });

        async function generateResponse(question) {
            try {
                console.log(`=== Generating response for: "${question}" ===`);
                
                // Find relevant document chunks using semantic search
                const relevantChunks = await findRelevantChunks(question, 5);
                
                console.log(`Found ${relevantChunks.length} relevant chunks`);
                
                if (relevantChunks.length === 0) {
                    // Add debug info to the response
                    const debugInfo = `Debug: Searched ${documentChunks.length} chunks, but no relevant content found. Try different keywords or check document content.`;
                    
                    return {
                        text: "I couldn't find specific information about that topic in our policy documents. Could you try rephrasing your question or asking about a different policy area?\n\n" + debugInfo,
                        sources: []
                    };
                }
                
                // Prepare context from relevant chunks
                const context = relevantChunks
                    .map((chunk, index) => `[Document ${index + 1}] ${chunk.text}`)
                    .join('\n\n');
                
                console.log('Context being sent to AI:', context.substring(0, 500) + '...');
                
                // Generate response using AI
                const aiResponse = await callAIAPI(question, context);
                
                console.log('AI Response received:', aiResponse.substring(0, 200) + '...');
                
                return {
                    text: aiResponse,
                    sources: relevantChunks.map(chunk => ({
                        file: chunk.source,
                        page: chunk.page,
                        relevanceScore: chunk.score
                    }))
                };
                
            } catch (error) {
                console.error('Error in generateResponse:', error);
                return {
                    text: `Error: ${error.message}. Debug info: Question="${question}", Chunks available=${documentChunks.length}`,
                    sources: []
                };
            }
        }

        async function findRelevantChunks(question, topK = 5) {
            if (documentChunks.length === 0) {
                console.log('No document chunks available');
                return [];
            }
            
            console.log(`Searching for: "${question}"`);
            console.log(`Available chunks: ${documentChunks.length}`);
            
            // Generate embedding for the question
            let questionEmbedding;
            let similarities = [];
            
            if (config.provider === 'openai' && embeddings.length > 0) {
                try {
                    questionEmbedding = await generateOpenAIEmbeddings([{ text: question }]);
                    questionEmbedding = questionEmbedding[0];
                    
                    // Calculate similarity scores
                    similarities = embeddings.map((embedding, index) => ({
                        index,
                        score: calculateCosineSimilarity(questionEmbedding, embedding),
                        chunk: documentChunks[index]
                    }));
                } catch (error) {
                    console.log('Embedding search failed, falling back to keyword search');
                    similarities = performKeywordSearch(question);
                }
            } else {
                // Use keyword search as fallback
                console.log('Using keyword search');
                similarities = performKeywordSearch(question);
            }
            
            // Sort by similarity and return top K
            const results = similarities
                .sort((a, b) => b.score - a.score)
                .slice(0, topK)
                .filter(item => item.score > 0.05) // Lower threshold for better recall
                .map(item => ({
                    ...item.chunk,
                    score: item.score
                }));
            
            console.log(`Found ${results.length} relevant chunks:`, 
                results.map(r => ({ score: r.score.toFixed(3), preview: r.text.substring(0, 100) + '...' }))
            );
            
            return results;
        }

        function performKeywordSearch(question) {
            const queryWords = question.toLowerCase()
                .replace(/[^\w\s]/g, ' ')
                .split(/\s+/)
                .filter(word => word.length > 2)
                .filter(word => !['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'what', 'how', 'when', 'where', 'why', 'who'].includes(word));
            
            console.log('Search keywords:', queryWords);
            
            return documentChunks.map((chunk, index) => {
                const chunkText = chunk.text.toLowerCase();
                let score = 0;
                
                // Exact phrase matching (higher weight)
                if (chunkText.includes(question.toLowerCase())) {
                    score += 1.0;
                }
                
                // Individual word matching
                queryWords.forEach(word => {
                    const wordCount = (chunkText.match(new RegExp(word, 'g')) || []).length;
                    score += wordCount * 0.1;
                });
                
                // Boost score for shorter chunks that match (more focused content)
                if (score > 0 && chunk.text.length < 1000) {
                    score *= 1.2;
                }
                
                return {
                    index,
                    score,
                    chunk
                };
            });
        }

        function calculateCosineSimilarity(vecA, vecB) {
            if (!vecA || !vecB || vecA.length !== vecB.length) {
                return 0;
            }
            
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            
            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                normA += vecA[i] * vecA[i];
                normB += vecB[i] * vecB[i];
            }
            
            const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
            return magnitude === 0 ? 0 : dotProduct / magnitude;
        }

        async function callAIAPI(question, context) {
            // Always use Groq API
            return await callGroqAPI(question, context);
        }

        async function callOpenAIAPI(question, context) {
            try {
                console.log('Calling OpenAI API...');
                console.log('Question:', question);
                console.log('Context length:', context.length);
                
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: `You are a helpful assistant for a community college. Your role is to answer questions about college policies and procedures based on the provided context from official policy documents.

Guidelines:
- Always base your answers on the provided context from policy documents
- Be accurate and cite specific policies when possible
- If the context doesn't contain enough information, say so clearly
- Use a professional but friendly tone appropriate for college staff and students
- Focus on practical, actionable information
- If asked about something not covered in the policies, direct users to contact the appropriate department

Context from policy documents:
${context}`
                            },
                            {
                                role: 'user',
                                content: question
                            }
                        ],
                        temperature: 0.3,
                        max_tokens: 500
                    })
                });

                console.log('API Response status:', response.status);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('API Error:', errorData);
                    throw new Error(`OpenAI API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                }

                const data = await response.json();
                console.log('API Response data:', data);
                
                const aiResponse = data.choices[0].message.content;
                console.log('Final AI response:', aiResponse);
                
                return aiResponse;

            } catch (error) {
                console.error('OpenAI API call failed:', error);
                throw new Error(`Failed to get response from OpenAI: ${error.message}`);
            }
        }

        async function callGroqAPI(question, context) {
            try {
                console.log('Calling Groq API...');
                console.log('Question:', question);
                console.log('Context length:', context.length);
                
                const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'llama-3.3-70b-versatile',
                        messages: [
                            {
                                role: 'system',
                                content: `You are a helpful assistant for a community college. Your role is to answer questions about college policies and procedures based on the provided context from official policy documents.

Guidelines:
- Always base your answers on the provided context from policy documents
- Be accurate and cite specific policies when possible
- If the context doesn't contain enough information, say so clearly
- Use a professional but friendly tone appropriate for college staff and students
- Focus on practical, actionable information
- If asked about something not covered in the policies, direct users to contact the appropriate department

Context from policy documents:
${context}`
                            },
                            {
                                role: 'user',
                                content: question
                            }
                        ],
                        temperature: 0.3,
                        max_tokens: 500
                    })
                });

                console.log('API Response status:', response.status);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('API Error:', errorData);
                    
                    // If this model fails, try fallback models
                    if (response.status === 400 && errorData.error?.message?.includes('decommissioned')) {
                        console.log('Trying fallback model...');
                        return await callGroqAPIFallback(question, context);
                    }
                    
                    throw new Error(`Groq API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                }

                const data = await response.json();
                console.log('API Response data:', data);
                
                const aiResponse = data.choices[0].message.content;
                console.log('Final AI response:', aiResponse);
                
                return aiResponse;

            } catch (error) {
                console.error('Groq API call failed:', error);
                throw new Error(`Failed to get response from Groq: ${error.message}`);
            }
        }

        async function callGroqAPIFallback(question, context) {
            // Try alternative Groq models
            const fallbackModels = [
                'llama-3.1-8b-instant',
                'mixtral-8x7b-32768',
                'gemma2-9b-it'
            ];
            
            for (const model of fallbackModels) {
                try {
                    console.log(`Trying fallback model: ${model}`);
                    
                    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${config.apiKey}`
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: [
                                {
                                    role: 'system',
                                    content: `You are a helpful assistant for a community college. Answer questions about policies based on the provided context.

Context: ${context}`
                                },
                                {
                                    role: 'user',
                                    content: question
                                }
                            ],
                            temperature: 0.3,
                            max_tokens: 500
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        console.log(`Success with fallback model: ${model}`);
                        return data.choices[0].message.content;
                    }
                } catch (error) {
                    console.log(`Fallback model ${model} failed:`, error);
                    continue;
                }
            }
            
            throw new Error('All Groq models failed. Please try OpenAI or check your API key.');
        }

        function addMessage(text, type, sources = []) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}-message`;
            
            let messageContent = text;
            
            if (type === 'bot' && sources && sources.length > 0) {
                const sourceInfo = sources.map(source => {
                    const relevanceText = source.relevanceScore ? 
                        `<span class="relevance-score">${Math.round(source.relevanceScore * 100)}%</span>` : '';
                    
                    return `<div class="source-item">
                        <span>📄 ${source.file} (page ${source.page})</span>
                        ${relevanceText}
                    </div>`;
                }).join('');
                
                messageContent += `<div class="source-info"><strong>Sources:</strong><br>${sourceInfo}</div>`;
            }
            
            messageDiv.innerHTML = messageContent;
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function showTyping(show) {
            const indicator = document.getElementById('typingIndicator');
            indicator.style.display = show ? 'flex' : 'none';
            
            if (show) {
                const messagesContainer = document.getElementById('chatMessages');
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }

        // Enter key handler
        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Auto-resize and focus management
        window.addEventListener('load', function() {
            document.getElementById('messageInput').focus();
        });
    </script>
</body>
</html>
