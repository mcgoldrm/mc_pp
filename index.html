<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>College Policy Assistant</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .chat-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 800px;
            height: 600px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .chat-header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }
        
        .chat-header h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }
        
        .chat-header p {
            opacity: 0.9;
            font-size: 0.9rem;
        }
        
        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #e74c3c;
            animation: pulse 2s infinite;
        }
        
        .status-dot.ready {
            background: #2ecc71;
            animation: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .message {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 18px;
            line-height: 1.4;
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-message {
            background: #007bff;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }
        
        .bot-message {
            background: #f8f9fa;
            color: #333;
            border: 1px solid #e9ecef;
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }
        
        .bot-message .source-info {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #dee2e6;
            font-size: 0.8rem;
            color: #6c757d;
        }
        
        .source-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .relevance-score {
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            color: #495057;
        }
        
        .loading-bar {
            width: 100%;
            height: 4px;
            background: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #0056b3);
            border-radius: 2px;
            transition: width 0.3s ease;
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { background-position: -200px 0; }
            100% { background-position: 200px 0; }
        }
        
        .typing-indicator {
            display: none;
            align-self: flex-start;
            background: #f8f9fa;
            padding: 12px 16px;
            border-radius: 18px;
            border-bottom-left-radius: 4px;
        }
        
        .typing-dots {
            display: flex;
            gap: 4px;
        }
        
        .typing-dots span {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #007bff;
            animation: typing 1.4s infinite;
        }
        
        .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }
        
        .chat-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
        }
        
        .input-container {
            flex: 1;
            position: relative;
        }
        
        #messageInput {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e9ecef;
            border-radius: 25px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s ease;
        }
        
        #messageInput:focus {
            border-color: #007bff;
        }
        
        #sendButton {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        #sendButton:hover:not(:disabled) {
            background: #0056b3;
            transform: scale(1.05);
        }
        
        #sendButton:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        
        .config-panel {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .config-row {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .config-row label {
            font-weight: 600;
            min-width: 100px;
        }
        
        .config-row input, .config-row select {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
        }
        
        .welcome-message {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            margin: 40px 0;
        }
        
        @media (max-width: 600px) {
            .chat-container {
                height: 100vh;
                border-radius: 0;
            }
            
            .message {
                max-width: 90%;
            }
            
            .config-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .config-row label {
                min-width: auto;
                margin-bottom: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <h1>ðŸŽ“ College Policy Assistant</h1>
            <p>Ask questions about our policies and procedures</p>
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Setup Required</span>
            </div>
        </div>
        
        <div class="chat-messages" id="chatMessages">
            <div class="config-panel" id="configPanel">
                <h3 style="margin-bottom: 15px; color: #333;">ðŸ”§ Configuration</h3>
                <div class="config-row">
                    <label for="aiProvider">AI Provider:</label>
                    <select id="aiProvider">
                        <option value="openai">OpenAI GPT-4 (Recommended)</option>
                        <option value="llama">Llama via Groq</option>
                    </select>
                </div>
                <div class="config-row">
                    <label for="apiKey">API Key:</label>
                    <input type="password" id="apiKey" placeholder="Enter your API key">
                    <small style="color: #6c757d; font-size: 0.8rem; margin-top: 4px; display: block;">
                        OpenAI: Get from <a href="https://platform.openai.com/api-keys" target="_blank">platform.openai.com</a> | 
                        Groq: Get from <a href="https://console.groq.com/keys" target="_blank">console.groq.com</a>
                    </small>
                </div>
                <div class="config-row">
                    <label for="pdfFolder">PDF Folder URL:</label>
                    <input type="text" id="pdfFolder" placeholder="https://your-username.github.io/your-repo/pdfs/">
                </div>
                <button onclick="initializeBot()" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 10px;">
                    Initialize Assistant
                </button>
            </div>
            
            <div class="welcome-message" id="welcomeMessage" style="display: none;">
                Welcome! I'm ready to help you find information about college policies and procedures. What would you like to know?
            </div>
            
            <div class="typing-indicator" id="typingIndicator">
                <div class="typing-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        
        <div class="chat-input">
            <div class="input-container">
                <input type="text" id="messageInput" placeholder="Ask about policies, procedures, or guidelines..." disabled>
            </div>
            <button id="sendButton" disabled onclick="sendMessage()">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                </svg>
            </button>
        </div>
    </div>

    <!-- PDF.js for PDF processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <script>
        // Configuration
        let config = {
            apiKey: '',
            provider: 'openai',
            pdfFolderUrl: '',
            isInitialized: false
        };
        
        // Document storage
        let documentChunks = [];
        let embeddings = [];
        let loadingProgress = 0;
        
        // Common PDF files to look for in the folder
        const commonPolicyFiles = [
            'student-handbook.pdf',
            'employee-handbook.pdf',
            'academic-policies.pdf',
            'campus-safety.pdf',
            'technology-policies.pdf',
            'facilities-policies.pdf',
            'hr-policies.pdf',
            'financial-policies.pdf',
            'student-code-of-conduct.pdf',
            'faculty-handbook.pdf',
            'emergency-procedures.pdf',
            'it-acceptable-use.pdf'
        ];

        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        async function initializeBot() {
            const provider = document.getElementById('aiProvider').value;
            const apiKey = document.getElementById('apiKey').value;
            const pdfFolder = document.getElementById('pdfFolder').value;

            if (!apiKey || !pdfFolder) {
                alert('Please fill in all configuration fields');
                return;
            }

            config = { provider, apiKey, pdfFolderUrl: pdfFolder, isInitialized: true };
            
            updateStatus('Initializing...', false);
            
            try {
                // Simulate document loading process
                await loadDocuments();
                
                // Hide config panel and show welcome
                document.getElementById('configPanel').style.display = 'none';
                document.getElementById('welcomeMessage').style.display = 'block';
                
                // Enable input
                document.getElementById('messageInput').disabled = false;
                document.getElementById('sendButton').disabled = false;
                
                updateStatus('Ready', true);
                
                // Focus on input
                document.getElementById('messageInput').focus();
            } catch (error) {
                console.error('Initialization failed:', error);
                updateStatus('Setup Required', false);
                alert('Failed to initialize. Please check your configuration.');
            }
        }

        async function loadDocuments() {
            updateStatus('Loading documents...', false);
            
            try {
                // Discover available PDF files
                const availableFiles = await discoverPDFFiles();
                console.log(`Found ${availableFiles.length} PDF files to process`);
                
                if (availableFiles.length === 0) {
                    throw new Error('No PDF files found in the specified folder');
                }
                
                // Process each PDF
                documentChunks = [];
                embeddings = [];
                loadingProgress = 0;
                
                for (let i = 0; i < availableFiles.length; i++) {
                    const fileName = availableFiles[i];
                    updateStatus(`Processing ${fileName}... (${i + 1}/${availableFiles.length})`, false);
                    
                    try {
                        const chunks = await processPDF(fileName);
                        documentChunks.push(...chunks);
                        console.log(`Processed ${fileName}: ${chunks.length} chunks`);
                    } catch (error) {
                        console.error(`Failed to process ${fileName}:`, error);
                        // Continue with other files
                    }
                    
                    loadingProgress = ((i + 1) / availableFiles.length) * 100;
                }
                
                if (documentChunks.length === 0) {
                    throw new Error('No content could be extracted from PDF files');
                }
                
                // Generate embeddings for all chunks
                updateStatus('Generating embeddings...', false);
                await generateAllEmbeddings();
                
                console.log(`Successfully loaded ${documentChunks.length} document chunks with embeddings`);
                
            } catch (error) {
                console.error('Document loading failed:', error);
                throw error;
            }
        }

        async function discoverPDFFiles() {
            // Try to fetch a directory listing or check common files
            const availableFiles = [];
            
            for (const fileName of commonPolicyFiles) {
                try {
                    const response = await fetch(`${config.pdfFolderUrl}${fileName}`, { method: 'HEAD' });
                    if (response.ok) {
                        availableFiles.push(fileName);
                    }
                } catch (error) {
                    // File doesn't exist, continue
                    console.log(`${fileName} not found, skipping`);
                }
            }
            
            return availableFiles;
        }

        async function processPDF(fileName) {
            const pdfUrl = `${config.pdfFolderUrl}${fileName}`;
            
            try {
                // Load PDF
                const loadingTask = pdfjsLib.getDocument(pdfUrl);
                const pdf = await loadingTask.promise;
                
                const chunks = [];
                const chunkSize = 1000; // Characters per chunk
                const overlapSize = 200; // Overlap between chunks
                
                // Process each page
                for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                    const page = await pdf.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    
                    // Extract text from page
                    const pageText = textContent.items
                        .map(item => item.str)
                        .join(' ')
                        .replace(/\s+/g, ' ')
                        .trim();
                    
                    if (pageText.length > 50) { // Only process pages with substantial content
                        // Split page into chunks
                        const pageChunks = createTextChunks(pageText, chunkSize, overlapSize);
                        
                        pageChunks.forEach((chunkText, chunkIndex) => {
                            chunks.push({
                                text: chunkText,
                                source: fileName,
                                page: pageNum,
                                chunkId: `${fileName}_p${pageNum}_c${chunkIndex}`,
                                wordCount: chunkText.split(' ').length
                            });
                        });
                    }
                }
                
                return chunks;
                
            } catch (error) {
                console.error(`Error processing PDF ${fileName}:`, error);
                throw new Error(`Failed to process ${fileName}: ${error.message}`);
            }
        }

        function createTextChunks(text, chunkSize, overlapSize) {
            const chunks = [];
            let startIndex = 0;
            
            while (startIndex < text.length) {
                let endIndex = startIndex + chunkSize;
                
                // If we're not at the end, try to break at a sentence or word boundary
                if (endIndex < text.length) {
                    // Look for sentence boundary
                    const sentenceEnd = text.lastIndexOf('.', endIndex);
                    const questionEnd = text.lastIndexOf('?', endIndex);
                    const exclamationEnd = text.lastIndexOf('!', endIndex);
                    
                    const bestSentenceEnd = Math.max(sentenceEnd, questionEnd, exclamationEnd);
                    
                    if (bestSentenceEnd > startIndex + chunkSize * 0.7) {
                        endIndex = bestSentenceEnd + 1;
                    } else {
                        // Fallback to word boundary
                        const wordEnd = text.lastIndexOf(' ', endIndex);
                        if (wordEnd > startIndex + chunkSize * 0.7) {
                            endIndex = wordEnd;
                        }
                    }
                }
                
                const chunk = text.slice(startIndex, endIndex).trim();
                if (chunk.length > 100) { // Only add substantial chunks
                    chunks.push(chunk);
                }
                
                // Move start index, accounting for overlap
                startIndex = endIndex - overlapSize;
                if (startIndex >= text.length) break;
            }
            
            return chunks;
        }

        async function generateAllEmbeddings() {
            embeddings = [];
            
            // Process embeddings in batches to avoid rate limits
            const batchSize = 10;
            
            for (let i = 0; i < documentChunks.length; i += batchSize) {
                const batch = documentChunks.slice(i, i + batchSize);
                const batchEmbeddings = await generateEmbeddingBatch(batch);
                embeddings.push(...batchEmbeddings);
                
                // Small delay between batches
                if (i + batchSize < documentChunks.length) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
        }

        async function generateEmbeddingBatch(chunks) {
            if (config.provider === 'openai') {
                return await generateOpenAIEmbeddings(chunks);
            } else {
                // For Llama, we'll use a simple TF-IDF approach as embeddings
                return generateTFIDFEmbeddings(chunks);
            }
        }

        async function generateOpenAIEmbeddings(chunks) {
            try {
                const response = await fetch('https://api.openai.com/v1/embeddings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'text-embedding-3-small',
                        input: chunks.map(chunk => chunk.text)
                    })
                });

                if (!response.ok) {
                    throw new Error(`OpenAI API error: ${response.status}`);
                }

                const data = await response.json();
                return data.data.map(item => item.embedding);
                
            } catch (error) {
                console.error('Error generating OpenAI embeddings:', error);
                // Fallback to TF-IDF
                return generateTFIDFEmbeddings(chunks);
            }
        }

        function generateTFIDFEmbeddings(chunks) {
            // Simple TF-IDF implementation for embeddings
            const vocabulary = new Set();
            const documents = chunks.map(chunk => {
                const words = chunk.text.toLowerCase()
                    .replace(/[^\w\s]/g, ' ')
                    .split(/\s+/)
                    .filter(word => word.length > 2);
                
                words.forEach(word => vocabulary.add(word));
                return words;
            });

            const vocabArray = Array.from(vocabulary);
            const embeddings = [];

            documents.forEach(doc => {
                const embedding = new Array(Math.min(vocabArray.length, 384)).fill(0);
                const docLength = doc.length;

                doc.forEach(word => {
                    const index = vocabArray.indexOf(word);
                    if (index !== -1 && index < embedding.length) {
                        embedding[index] += 1 / docLength; // Simple TF
                    }
                });

                // Normalize
                const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
                if (magnitude > 0) {
                    for (let i = 0; i < embedding.length; i++) {
                        embedding[i] /= magnitude;
                    }
                }

                embeddings.push(embedding);
            });

            return embeddings;
        }

        function updateStatus(text, ready) {
            document.getElementById('statusText').textContent = text;
            document.getElementById('statusDot').className = ready ? 'status-dot ready' : 'status-dot';
        }

        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message || !config.isInitialized) return;
            
            // Add user message
            addMessage(message, 'user');
            input.value = '';
            
            // Show typing indicator
            showTyping(true);
            
            try {
                const response = await generateResponse(message);
                addMessage(response.text, 'bot', response.sources);
            } catch (error) {
                console.error('Error generating response:', error);
                addMessage('I apologize, but I encountered an error processing your question. Please try again.', 'bot');
            } finally {
                showTyping(false);
            }
        }

        async function generateResponse(question) {
            try {
                // Find relevant document chunks using semantic search
                const relevantChunks = await findRelevantChunks(question, 5);
                
                if (relevantChunks.length === 0) {
                    return {
                        text: "I couldn't find specific information about that topic in our policy documents. Could you try rephrasing your question or asking about a different policy area?",
                        sources: []
                    };
                }
                
                // Prepare context from relevant chunks
                const context = relevantChunks
                    .map((chunk, index) => `[Document ${index + 1}] ${chunk.text}`)
                    .join('\n\n');
                
                // Generate response using AI
                const aiResponse = await callAIAPI(question, context);
                
                return {
                    text: aiResponse,
                    sources: relevantChunks.map(chunk => ({
                        file: chunk.source,
                        page: chunk.page,
                        relevanceScore: chunk.score
                    }))
                };
                
            } catch (error) {
                console.error('Error in generateResponse:', error);
                throw error;
            }
        }

        async function findRelevantChunks(question, topK = 5) {
            if (documentChunks.length === 0) {
                return [];
            }
            
            // Generate embedding for the question
            let questionEmbedding;
            
            if (config.provider === 'openai') {
                questionEmbedding = await generateOpenAIEmbeddings([{ text: question }]);
                questionEmbedding = questionEmbedding[0];
            } else {
                questionEmbedding = generateTFIDFEmbeddings([{ text: question }])[0];
            }
            
            // Calculate similarity scores
            const similarities = embeddings.map((embedding, index) => ({
                index,
                score: calculateCosineSimilarity(questionEmbedding, embedding),
                chunk: documentChunks[index]
            }));
            
            // Sort by similarity and return top K
            return similarities
                .sort((a, b) => b.score - a.score)
                .slice(0, topK)
                .filter(item => item.score > 0.1) // Filter out very low similarity
                .map(item => ({
                    ...item.chunk,
                    score: item.score
                }));
        }

        function calculateCosineSimilarity(vecA, vecB) {
            if (!vecA || !vecB || vecA.length !== vecB.length) {
                return 0;
            }
            
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            
            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                normA += vecA[i] * vecA[i];
                normB += vecB[i] * vecB[i];
            }
            
            const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
            return magnitude === 0 ? 0 : dotProduct / magnitude;
        }

        async function callAIAPI(question, context) {
            if (config.provider === 'openai') {
                return await callOpenAIAPI(question, context);
            } else {
                return await callGroqAPI(question, context);
            }
        }

        async function callOpenAIAPI(question, context) {
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: `You are a helpful assistant for a community college. Your role is to answer questions about college policies and procedures based on the provided context from official policy documents.

Guidelines:
- Always base your answers on the provided context from policy documents
- Be accurate and cite specific policies when possible
- If the context doesn't contain enough information, say so clearly
- Use a professional but friendly tone appropriate for college staff and students
- Focus on practical, actionable information
- If asked about something not covered in the policies, direct users to contact the appropriate department

Context from policy documents:
${context}`
                            },
                            {
                                role: 'user',
                                content: question
                            }
                        ],
                        temperature: 0.3,
                        max_tokens: 500
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`OpenAI API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;

            } catch (error) {
                console.error('OpenAI API call failed:', error);
                throw new Error(`Failed to get response from OpenAI: ${error.message}`);
            }
        }

        async function callGroqAPI(question, context) {
            try {
                const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'llama-3.1-70b-versatile',
                        messages: [
                            {
                                role: 'system',
                                content: `You are a helpful assistant for a community college. Your role is to answer questions about college policies and procedures based on the provided context from official policy documents.

Guidelines:
- Always base your answers on the provided context from policy documents
- Be accurate and cite specific policies when possible
- If the context doesn't contain enough information, say so clearly
- Use a professional but friendly tone appropriate for college staff and students
- Focus on practical, actionable information
- If asked about something not covered in the policies, direct users to contact the appropriate department

Context from policy documents:
${context}`
                            },
                            {
                                role: 'user',
                                content: question
                            }
                        ],
                        temperature: 0.3,
                        max_tokens: 500
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`Groq API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;

            } catch (error) {
                console.error('Groq API call failed:', error);
                throw new Error(`Failed to get response from Groq: ${error.message}`);
            }
        }

        function addMessage(text, type, sources = []) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}-message`;
            
            let messageContent = text;
            
            if (type === 'bot' && sources && sources.length > 0) {
                const sourceInfo = sources.map(source => {
                    const relevanceText = source.relevanceScore ? 
                        `<span class="relevance-score">${Math.round(source.relevanceScore * 100)}%</span>` : '';
                    
                    return `<div class="source-item">
                        <span>ðŸ“„ ${source.file} (page ${source.page})</span>
                        ${relevanceText}
                    </div>`;
                }).join('');
                
                messageContent += `<div class="source-info"><strong>Sources:</strong><br>${sourceInfo}</div>`;
            }
            
            messageDiv.innerHTML = messageContent;
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function showTyping(show) {
            const indicator = document.getElementById('typingIndicator');
            indicator.style.display = show ? 'flex' : 'none';
            
            if (show) {
                const messagesContainer = document.getElementById('chatMessages');
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }

        // Enter key handler
        document.getElementById('messageInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Auto-resize and focus management
        window.addEventListener('load', function() {
            document.getElementById('messageInput').focus();
        });
    </script>
</body>
</html>
